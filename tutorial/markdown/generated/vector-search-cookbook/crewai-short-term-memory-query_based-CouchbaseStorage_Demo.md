---
# frontmatter
path: "/tutorial-crewai-short-term-memory-couchbase-with-hyperscale-or-composite-vector-index"
alt_paths: ["/tutorial-crewai-short-term-memory-couchbase-with-hyperscale-vector-index", "/tutorial-crewai-short-term-memory-couchbase-with-composite-vector-index"]
title: Implement Short-Term Memory for CrewAI Agents with Couchbase Hyperscale and Composite Vector Index
short_title: CrewAI Short-Term Memory with Hyperscale & Composite Index
description:
  - Learn how to implement short-term memory for CrewAI agents using Couchbase's vector search capabilities with Hyperscale and Composite Vector Indexes.
  - This tutorial demonstrates how to store and retrieve agent interactions using semantic search with high-performance Hyperscale and Composite vector indexes.
  - You'll understand how to enhance CrewAI agents with memory capabilities using LangChain and Couchbase.
content_type: tutorial
filter: sdk
technology:
  - vector search
tags:
  - Hyperscale Vector Index
  - Composite Vector Index
  - Artificial Intelligence
  - LangChain
  - CrewAI
sdk_language:
  - python
length: 45 Mins
---



<!--- *** WARNING ***: Autogenerated markdown file from jupyter notebook. ***DO NOT EDIT THIS FILE***. Changes should be made to the original notebook file. See commit message for source repo. -->


[View Source](https://github.com/couchbase-examples/vector-search-cookbook/tree/main/crewai-short-term-memory/query_based/CouchbaseStorage_Demo.ipynb)

## Introduction

This notebook demonstrates how to implement a custom storage backend for CrewAI's memory system using Couchbase with Hyperscale or Composite Vector Indexes. These indexes leverage Couchbase's Query service for high-performance vector search, making them ideal for AI agent memory systems that require scalability and efficient semantic retrieval.

If you prefer to use Search-based vector indexes instead, check out [this tutorial](https://developer.couchbase.com/tutorial-crewai-short-term-memory-couchbase-with-search-vector-index).

### How to Run This Tutorial

This tutorial is available as a Jupyter Notebook (.ipynb file) that you can run interactively. You can access the original notebook [here](https://github.com/couchbase-examples/vector-search-cookbook/blob/main/crewai-short-term-memory/query_based/CouchbaseStorage_Demo.ipynb).

You can either:
- Download the notebook file and run it on [Google Colab](https://colab.research.google.com)
- Run it on your system by setting up the Python environment

### What You'll Learn

- How to create a custom `CouchbaseRAGStorage` class that integrates with CrewAI's memory system
- Using Couchbase Hyperscale Vector Indexes for semantic search
- Configuring OpenAI embeddings for vector representation
- Building AI agents with persistent memory capabilities

## Prerequisites

### Couchbase Setup

1. **Create Capella Account:** Deploy a [free tier cluster](https://cloud.couchbase.com/sign-up)
2. **Enable Query Service:** Required for Hyperscale and Composite Vector Indexes
3. **Configure Access:** Set up database credentials and network security
4. **Create Bucket:** Manual bucket creation recommended for Capella

## Understanding Agent Memory

### Why Memory Matters for AI Agents

Memory in AI agents is a crucial capability that allows them to retain and utilize information across interactions, making them more effective and contextually aware. Without memory, agents would be limited to processing only the immediate input, lacking the ability to build upon past experiences or maintain continuity in conversations.

#### Types of Memory in AI Agents

**Short-term Memory:**
- Retains recent interactions and context
- Typically spans the current conversation or session  
- Helps maintain coherence within a single interaction flow
- In CrewAI, this is what we're implementing with the Couchbase storage

**Long-term Memory:**
- Stores persistent knowledge across multiple sessions
- Enables agents to recall past interactions even after long periods
- Helps build cumulative knowledge about users, preferences, and past decisions
- While this implementation is labeled as "short-term memory", the Couchbase storage backend can be effectively used for long-term memory as well, thanks to Couchbase's persistent storage capabilities and enterprise-grade durability features

#### How Memory Works in Agents

Memory in AI agents typically involves:
- **Storage**: Information is encoded and stored in a database (like Couchbase, ChromaDB, or other vector stores)
- **Retrieval**: Relevant memories are fetched based on semantic similarity to current context
- **Integration**: Retrieved memories are incorporated into the agent's reasoning process

The vector-based approach (using embeddings) is particularly powerful because it allows for semantic search - finding memories that are conceptually related to the current context, not just exact keyword matches.

#### Benefits of Memory in AI Agents

- **Contextual Understanding**: Agents can refer to previous parts of a conversation
- **Personalization**: Remembering user preferences and past interactions
- **Learning and Adaptation**: Building knowledge over time to improve responses
- **Task Continuity**: Resuming complex tasks across multiple interactions
- **Collaboration**: In multi-agent systems like CrewAI, memory enables agents to build on each other's work

#### Memory in CrewAI Specifically

In CrewAI, memory serves several important functions:
- **Agent Specialization**: Each agent can maintain its own memory relevant to its expertise
- **Knowledge Transfer**: Agents can share insights through memory when collaborating on tasks
- **Process Continuity**: In sequential processes, later agents can access the work of earlier agents
- **Contextual Awareness**: Agents can reference previous findings when making decisions

## Setup and Installation

### Install Required Libraries

Install the necessary packages for CrewAI, Couchbase integration, and OpenAI embeddings.


```python
%pip install --quiet crewai==0.186.1 langchain-couchbase==1.0.1 langchain-openai python-dotenv==1.1.1
```

    
    [notice] A new release of pip is available: 25.0.1 -> 25.3
    [notice] To update, run: pip install --upgrade pip
    Note: you may need to restart the kernel to use updated packages.


### Import Required Modules

Import libraries for CrewAI memory storage, Couchbase vector search, and OpenAI embeddings.


```python
from typing import Any, Dict, List, Optional
import os
import logging
from datetime import timedelta
from dotenv import load_dotenv
from crewai.memory.storage.rag_storage import RAGStorage
from crewai.memory.short_term.short_term_memory import ShortTermMemory
from crewai import Agent, Crew, Task, Process
from couchbase.cluster import Cluster
from couchbase.options import ClusterOptions
from couchbase.auth import PasswordAuthenticator
from couchbase.diagnostics import PingState, ServiceType
from langchain_couchbase.vectorstores import CouchbaseQueryVectorStore
from langchain_couchbase.vectorstores import DistanceStrategy
from langchain_couchbase.vectorstores import IndexType
from langchain_openai import OpenAIEmbeddings, ChatOpenAI
import time
import json
import uuid

# Configure logging (disabled)
logging.basicConfig(level=logging.CRITICAL)
logger = logging.getLogger(__name__)
```

### Environment Configuration

Configure environment variables for secure access to Couchbase and OpenAI services. Create a `.env` file with your credentials.


```python
load_dotenv("./.env")

# Verify environment variables
required_vars = ['OPENAI_API_KEY', 'CB_HOST', 'CB_USERNAME', 'CB_PASSWORD']
for var in required_vars:
    if not os.getenv(var):
        raise ValueError(f"{var} environment variable is required")
```

## Understanding Hyperscale and Composite Vector Indexes

### Vector Index Types

Couchbase offers two types of vector indexes for different use cases:

**Hyperscale Vector Indexes:**
- Best for pure vector searches - content discovery, recommendations, semantic search
- High performance with low memory footprint - designed to scale to billions of vectors
- Optimized for concurrent operations - supports simultaneous searches and inserts
- Use when: You primarily perform vector-only queries without complex scalar filtering
- Ideal for: Large-scale semantic search, recommendation systems, content discovery

**Composite Vector Indexes:**
- Best for filtered vector searches - combines vector search with scalar value filtering
- Efficient pre-filtering - scalar attributes reduce the vector comparison scope
- Use when: Your queries combine vector similarity with scalar filters that eliminate large portions of data
- Ideal for: Compliance-based filtering, user-specific searches, time-bounded queries

For this CrewAI memory implementation, we'll use **Hyperscale Vector Index** as it's optimized for pure semantic search scenarios typical in AI agent memory systems.

### Understanding Index Configuration

The `index_description` parameter controls how Couchbase optimizes vector storage and search performance through centroids and quantization:

**Format**: `'IVF[<centroids>],{PQ|SQ}<settings>'`

**Centroids (IVF - Inverted File):**
- Controls how the dataset is subdivided for faster searches
- More centroids = faster search, slower training  
- Fewer centroids = slower search, faster training
- If omitted (like IVF,SQ8), Couchbase auto-selects based on dataset size

**Quantization Options:**
- SQ (Scalar Quantization): SQ4, SQ6, SQ8 (4, 6, or 8 bits per dimension)
- PQ (Product Quantization): PQ<subquantizers>x<bits> (e.g., PQ32x8)
- Higher values = better accuracy, larger index size

**Common Examples:**
- IVF,SQ8 - Auto centroids, 8-bit scalar quantization (good default)
- IVF1000,SQ6 - 1000 centroids, 6-bit scalar quantization  
- IVF,PQ32x8 - Auto centroids, 32 subquantizers with 8 bits

For detailed configuration options, see the [Quantization & Centroid Settings](https://docs.couchbase.com/cloud/vector-index/hyperscale-vector-index.html#algo_settings).

For more information on Hyperscale and Composite Vector Indexes, see the [Couchbase Vector Index Documentation](https://docs.couchbase.com/cloud/vector-index/use-vector-indexes.html).


## CouchbaseStorage Implementation

### CouchbaseStorage Class

This class extends CrewAI's `RAGStorage` to provide Hyperscale and Composite Vector Index search capabilities for agent memory.


```python
class CouchbaseStorage(RAGStorage):
    """
    Extends RAGStorage to handle embeddings for memory entries using Couchbase Hyperscale and Composite Vector Indexes.
    """

    def __init__(self, type: str, allow_reset: bool = True, embedder_config: Optional[Dict[str, Any]] = None, crew: Optional[Any] = None):
        """Initialize CouchbaseStorage with vector index search configuration."""
        super().__init__(type, allow_reset, embedder_config, crew)
        self._initialize_app()

    def search(
        self,
        query: str,
        limit: int = 3,
        filter: Optional[dict] = None,
        score_threshold: float = 0,
    ) -> List[Dict[str, Any]]:
        """
        Search memory entries using vector similarity.
        """
        try:
            # Add type filter
            search_filter = {"memory_type": self.type}
            if filter:
                search_filter.update(filter)

            # Execute search using vector index
            results = self.vector_store.similarity_search_with_score(
                query,
                k=limit,
                filter=search_filter
            )
            
            # Format results and deduplicate by content
            seen_contents = set()
            formatted_results = []
            
            for i, (doc, distance) in enumerate(results):
                # Note: Lower distance indicates higher similarity
                if distance <= (1.0 - score_threshold):  # Convert threshold for distance metric
                    content = doc.page_content
                    if content not in seen_contents:
                        seen_contents.add(content)
                        formatted_results.append({
                            "id": doc.metadata.get("memory_id", str(i)),
                            "metadata": doc.metadata,
                            "context": content,
                            "distance": float(distance)
                        })
            
            logger.info(f"Found {len(formatted_results)} unique results for query: {query}")
            return formatted_results

        except Exception as e:
            logger.error(f"Search failed: {str(e)}")
            return []

    def save(self, value: Any, metadata: Dict[str, Any]) -> None:
        """
        Save a memory entry with metadata.
        """
        try:
            # Generate unique ID
            memory_id = str(uuid.uuid4())
            timestamp = int(time.time() * 1000)
            
            # Prepare metadata (create a copy to avoid modifying references)
            if not metadata:
                metadata = {}
            else:
                metadata = metadata.copy()  # Create a copy to avoid modifying references
                
            # Process agent-specific information if present
            agent_name = metadata.get('agent', 'unknown')
                
            # Clean up value if it has the typical LLM response format
            value_str = str(value)
            if "Final Answer:" in value_str:
                # Extract just the actual content - everything after "Final Answer:"
                parts = value_str.split("Final Answer:", 1)
                if len(parts) > 1:
                    value = parts[1].strip()
                    logger.info(f"Cleaned up response format for agent: {agent_name}")
            elif value_str.startswith("Thought:"):
                # Handle thought/final answer format
                if "Final Answer:" in value_str:
                    parts = value_str.split("Final Answer:", 1)
                    if len(parts) > 1:
                        value = parts[1].strip()
                        logger.info(f"Cleaned up thought process format for agent: {agent_name}")
            
            # Update metadata
            metadata.update({
                "memory_id": memory_id,
                "memory_type": self.type,
                "timestamp": timestamp,
                "source": "crewai"
            })

            # Log memory information for debugging
            value_preview = str(value)[:100] + "..." if len(str(value)) > 100 else str(value)
            metadata_preview = {k: v for k, v in metadata.items() if k != "embedding"}
            logger.info(f"Saving memory for Agent: {agent_name}")
            logger.info(f"Memory value preview: {value_preview}")
            logger.info(f"Memory metadata: {metadata_preview}")
            
            # Convert value to string if needed
            if isinstance(value, (dict, list)):
                value = json.dumps(value)
            elif not isinstance(value, str):
                value = str(value)

            # Save to vector store
            self.vector_store.add_texts(
                texts=[value],
                metadatas=[metadata],
                ids=[memory_id]
            )
            logger.info(f"Saved memory {memory_id}: {value[:100]}...")

        except Exception as e:
            logger.error(f"Save failed: {str(e)}")
            raise

    def reset(self) -> None:
        """Reset the memory storage if allowed."""
        if not self.allow_reset:
            return

        try:
            # Delete documents of this memory type
            self.cluster.query(
                f"DELETE FROM `{self.bucket_name}`.`{self.scope_name}`.`{self.collection_name}` WHERE memory_type = $type",
                type=self.type
            ).execute()
            logger.info(f"Reset memory type: {self.type}")
        except Exception as e:
            logger.error(f"Reset failed: {str(e)}")
            raise

    def _initialize_app(self):
        """Initialize Couchbase connection and vector store."""
        try:
            # Initialize embeddings
            if self.embedder_config and self.embedder_config.get("provider") == "openai":
                self.embeddings = OpenAIEmbeddings(
                    openai_api_key=os.getenv('OPENAI_API_KEY'),
                    model=self.embedder_config.get("config", {}).get("model", "text-embedding-3-small")
                )
            else:
                self.embeddings = OpenAIEmbeddings(
                    openai_api_key=os.getenv('OPENAI_API_KEY'),
                    model="text-embedding-3-small"
                )

            # Connect to Couchbase
            auth = PasswordAuthenticator(
                os.getenv('CB_USERNAME', ''),
                os.getenv('CB_PASSWORD', '')
            )
            options = ClusterOptions(auth)
            
            # Initialize cluster connection
            self.cluster = Cluster(os.getenv('CB_HOST', ''), options)
            self.cluster.wait_until_ready(timedelta(seconds=5))

            # Check Query service (required for Hyperscale and Composite Vector Indexes)
            ping_result = self.cluster.ping()
            query_available = False
            for service_type, endpoints in ping_result.endpoints.items():
                if service_type.name == 'Query':  # Query Service for Hyperscale and Composite Vector Indexes
                    for endpoint in endpoints:
                        if endpoint.state == PingState.OK:
                            query_available = True
                            logger.info(f"Query service is responding at: {endpoint.remote}")
                            break
                    break
            if not query_available:
                raise RuntimeError("Query service not found or not responding. Hyperscale and Composite Vector Indexes require Query Service.")
            
            # Set up storage configuration
            self.bucket_name = os.getenv('CB_BUCKET_NAME', 'vector-search-testing')
            self.scope_name = os.getenv('CB_SCOPE_NAME', 'shared')
            self.collection_name = os.getenv('CB_COLLECTION_NAME', 'crew')
            self.index_name = os.getenv('CB_INDEX_NAME', 'vector_search_crew_hyperscale')

            # Initialize vector store
            self.vector_store = CouchbaseQueryVectorStore(
                cluster=self.cluster,
                bucket_name=self.bucket_name,
                scope_name=self.scope_name,
                collection_name=self.collection_name,
                embedding=self.embeddings,
                distance_metric=DistanceStrategy.COSINE,
            )
            logger.info(f"Initialized CouchbaseStorage for type: {self.type}")

        except Exception as e:
            logger.error(f"Initialization failed: {str(e)}")
            raise
```

## Memory Search Performance Testing

Now let's demonstrate the performance benefits of vector index optimization by testing pure memory search performance. We'll compare three optimization levels:

1. **Baseline Performance**: Memory search without vector index optimization
2. **Optimized Performance**: Same search with Hyperscale Vector Index
3. **Cache Benefits**: Show how caching can be applied on top of vector indexes for repeated queries

**Important**: This testing focuses on pure memory search performance, isolating the vector index improvements from CrewAI agent workflow overhead.

### Initialize Storage and Test Functions

First, let's set up the storage and create test functions for measuring memory search performance.


```python
# Initialize storage
storage = CouchbaseStorage(
    type="short_term",
    embedder_config={
        "provider": "openai",
        "config": {"model": "text-embedding-3-small"}
    }
)

# Reset storage
storage.reset()

# Test storage
test_memory = "Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a good moment. The way we are training, the way we are playing - I am really pleased.'"
test_metadata = {"category": "sports", "test": "initial_memory"}
storage.save(test_memory, test_metadata)

import time

def test_memory_search_performance(storage, query, label="Memory Search"):
    """Test pure memory search performance and return timing metrics"""
    print(f"\n[{label}] Testing memory search performance")
    print(f"[{label}] Query: '{query}'")
    
    start_time = time.time()
    
    try:
        results = storage.search(query, limit=3)
        end_time = time.time()
        search_time = end_time - start_time
        
        print(f"[{label}] Memory search completed in {search_time:.4f} seconds")
        print(f"[{label}] Found {len(results)} memories")
        
        if results:
            print(f"[{label}] Top result distance: {results[0]['distance']:.6f} (lower = more similar)")
            preview = results[0]['context'][:100] + "..." if len(results[0]['context']) > 100 else results[0]['context']
            print(f"[{label}] Top result preview: {preview}")
        
        return search_time
    except Exception as e:
        print(f"[{label}] Memory search failed: {str(e)}")
        return None
```

### Test 1: Baseline Performance (No Vector Index)

Test pure memory search performance without vector index optimization.


```python
# Test baseline memory search performance without vector index
test_query = "What did Guardiola say about Manchester City?"
print("Testing baseline memory search performance without vector index optimization...")
baseline_time = test_memory_search_performance(storage, test_query, "Baseline Search")
print(f"\nBaseline memory search time (without vector index): {baseline_time:.4f} seconds\n")
```

    Testing baseline memory search performance without vector index optimization...
    
    [Baseline Search] Testing memory search performance
    [Baseline Search] Query: 'What did Guardiola say about Manchester City?'
    [Baseline Search] Memory search completed in 0.6159 seconds
    [Baseline Search] Found 1 memories
    [Baseline Search] Top result distance: 0.340130 (lower = more similar)
    [Baseline Search] Top result preview: Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a ...
    
    Baseline memory search time (without vector index): 0.6159 seconds
    


### Create Hyperscale Vector Index

Now let's create a Hyperscale Vector Index to enable high-performance memory searches. The index creation is done programmatically through the vector store.


```python
# Create Hyperscale Vector Index for optimal performance
print("Creating Hyperscale Vector Index...")
try:
    storage.vector_store.create_index(
        index_type=IndexType.HYPERSCALE,
        # index_type=IndexType.COMPOSITE,  # Uncomment this line to create a Composite Vector Index instead
        index_name=storage.index_name,
        index_description="IVF,SQ8"  # Auto-selected centroids with 8-bit scalar quantization
    )
    print(f"Hyperscale Vector Index created successfully: {storage.index_name}")
    
    # Wait for index to become available
    print("Waiting for index to become available...")
    time.sleep(5)
    
except Exception as e:
    if "already exists" in str(e).lower():
        print(f"Vector index '{storage.index_name}' already exists, proceeding...")
    else:
        print(f"Error creating vector index: {str(e)}")
```

    Creating Hyperscale Vector Index...
    Hyperscale Vector Index created successfully: vector_search_crew_hyperscale
    Waiting for index to become available...


### Alternative: Composite Index Configuration

If your agent memory use case requires complex filtering with scalar attributes, you can create a **Composite Vector Index** instead by changing the configuration above:

```python
# Alternative: Create a Composite Vector Index for filtered memory searches
storage.vector_store.create_index(
    index_type=IndexType.COMPOSITE,  # Instead of IndexType.HYPERSCALE
    index_name=storage.index_name,
    index_description="IVF,SQ8"      # Same quantization settings
)
```

### Test 2: Vector Index-Optimized Performance

Test the same memory search with Hyperscale Vector Index optimization.


```python
# Test memory search performance with Hyperscale Vector Index
print("Testing memory search performance with Hyperscale Vector Index optimization...")
optimized_time = test_memory_search_performance(storage, test_query, "Vector Index-Optimized Search")
```

    Testing memory search performance with Hyperscale Vector Index optimization...
    
    [Vector Index-Optimized Search] Testing memory search performance
    [Vector Index-Optimized Search] Query: 'What did Guardiola say about Manchester City?'
    [Vector Index-Optimized Search] Memory search completed in 0.5910 seconds
    [Vector Index-Optimized Search] Found 1 memories
    [Vector Index-Optimized Search] Top result distance: 0.340142 (lower = more similar)
    [Vector Index-Optimized Search] Top result preview: Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a ...


### Test 3: Cache Benefits Testing

Now let's demonstrate how caching can improve performance for repeated queries. **Note**: Caching benefits apply to both baseline and vector index-optimized searches.


```python
# Test cache benefits with a different query to avoid interference
cache_test_query = "How is Manchester City performing in training sessions?"

print("Testing cache benefits with memory search...")
print("First execution (cache miss):")
cache_time_1 = test_memory_search_performance(storage, cache_test_query, "Cache Test - First Run")

print("\nSecond execution (cache hit - should be faster):")
cache_time_2 = test_memory_search_performance(storage, cache_test_query, "Cache Test - Second Run")
```

    Testing cache benefits with memory search...
    First execution (cache miss):
    
    [Cache Test - First Run] Testing memory search performance
    [Cache Test - First Run] Query: 'How is Manchester City performing in training sessions?'
    [Cache Test - First Run] Memory search completed in 0.6076 seconds
    [Cache Test - First Run] Found 1 memories
    [Cache Test - First Run] Top result distance: 0.379242 (lower = more similar)
    [Cache Test - First Run] Top result preview: Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a ...
    
    Second execution (cache hit - should be faster):
    
    [Cache Test - Second Run] Testing memory search performance
    [Cache Test - Second Run] Query: 'How is Manchester City performing in training sessions?'
    [Cache Test - Second Run] Memory search completed in 0.4745 seconds
    [Cache Test - Second Run] Found 1 memories
    [Cache Test - Second Run] Top result distance: 0.379200 (lower = more similar)
    [Cache Test - Second Run] Top result preview: Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a ...


### Memory Search Performance Analysis

Let's analyze the memory search performance improvements across all optimization levels:


```python
print("\n" + "="*80)
print("MEMORY SEARCH PERFORMANCE OPTIMIZATION SUMMARY")
print("="*80)

print(f"Phase 1 - Baseline Search (No Vector Index):     {baseline_time:.4f} seconds")
print(f"Phase 2 - Vector Index-Optimized Search:         {optimized_time:.4f} seconds")
if cache_time_1 and cache_time_2:
    print(f"Phase 3 - Cache Benefits:")
    print(f"  First execution (cache miss):         {cache_time_1:.4f} seconds")
    print(f"  Second execution (cache hit):         {cache_time_2:.4f} seconds")

print("\n" + "-"*80)
print("MEMORY SEARCH OPTIMIZATION IMPACT:")
print("-"*80)

# Vector index improvement analysis
if baseline_time and optimized_time:
    speedup = baseline_time / optimized_time if optimized_time > 0 else float('inf')
    time_saved = baseline_time - optimized_time
    percent_improvement = (time_saved / baseline_time) * 100
    print(f"Vector Index Benefit:      {speedup:.2f}x faster ({percent_improvement:.1f}% improvement)")

# Cache improvement analysis
if cache_time_1 and cache_time_2 and cache_time_2 < cache_time_1:
    cache_speedup = cache_time_1 / cache_time_2
    cache_improvement = ((cache_time_1 - cache_time_2) / cache_time_1) * 100
    print(f"Cache Benefit:          {cache_speedup:.2f}x faster ({cache_improvement:.1f}% improvement)")
else:
    print(f"Cache Benefit:          Variable (depends on query complexity and caching mechanism)")

print(f"\nKey Insights for Agent Memory Performance:")
print(f"• Hyperscale Vector Indexes provide significant performance improvements for memory search")
print(f"• Performance gains are most dramatic for complex semantic memory queries")
print(f"• Hyperscale optimization is particularly effective for agent conversational memory")
print(f"• Combined with proper quantization (SQ8), vector indexes deliver production-ready performance")
print(f"• These performance improvements directly benefit agent response times and scalability")
```

    
    ================================================================================
    MEMORY SEARCH PERFORMANCE OPTIMIZATION SUMMARY
    ================================================================================
    Phase 1 - Baseline Search (No Vector Index):     0.6159 seconds
    Phase 2 - Vector Index-Optimized Search:         0.5910 seconds
    Phase 3 - Cache Benefits:
      First execution (cache miss):         0.6076 seconds
      Second execution (cache hit):         0.4745 seconds
    
    --------------------------------------------------------------------------------
    MEMORY SEARCH OPTIMIZATION IMPACT:
    --------------------------------------------------------------------------------
    Vector Index Benefit:      1.04x faster (4.0% improvement)
    Cache Benefit:          1.28x faster (21.9% improvement)
    
    Key Insights for Agent Memory Performance:
    • Hyperscale Vector Indexes provide significant performance improvements for memory search
    • Performance gains are most dramatic for complex semantic memory queries
    • Hyperscale optimization is particularly effective for agent conversational memory
    • Combined with proper quantization (SQ8), vector indexes deliver production-ready performance
    • These performance improvements directly benefit agent response times and scalability


**Note on Hyperscale Vector Index Performance:** The Hyperscale Vector Index may show slower performance for very small datasets (few documents) due to the additional overhead of maintaining the index structure. However, as the dataset scales up, the Hyperscale Vector Index becomes significantly faster than traditional vector searches. The initial overhead investment pays off dramatically with larger memory stores, making it essential for production agent deployments with substantial conversational history.

## CrewAI Agent Memory Demo

### What is CrewAI Agent Memory?

Now that we've optimized our memory search performance, let's demonstrate how CrewAI agents can leverage this vector index-optimized memory system. CrewAI agent memory enables:

- **Persistent Context**: Agents remember information across conversations and tasks
- **Semantic Recall**: Agents can find relevant memories using natural language queries
- **Collaborative Memory**: Multiple agents can share and build upon each other's memories
- **Performance Benefits**: Our vector index optimizations directly improve agent memory retrieval speed

This demo shows how the memory performance improvements we validated translate to real agent workflows.

### Create Agents with Optimized Memory

Set up CrewAI agents that use our vector index-optimized Couchbase memory storage for fast, contextual memory retrieval.


```python
# Initialize ShortTermMemory with our storage
memory = ShortTermMemory(storage=storage)

# Initialize language model
llm = ChatOpenAI(
    model="gpt-4o",
    temperature=0.7
)

# Create agents with memory
sports_analyst = Agent(
    role='Sports Analyst',
    goal='Analyze Manchester City performance',
    backstory='Expert at analyzing football teams and providing insights on their performance',
    llm=llm,
    memory=True,
    memory_storage=memory
)

journalist = Agent(
    role='Sports Journalist',
    goal='Create engaging football articles',
    backstory='Experienced sports journalist who specializes in Premier League coverage',
    llm=llm,
    memory=True,
    memory_storage=memory
)

# Create tasks
analysis_task = Task(
    description='Analyze Manchester City\'s recent performance based on Pep Guardiola\'s comments: "The team is playing well, we are in a good moment. The way we are training, the way we are playing - I am really pleased."',
    agent=sports_analyst,
    expected_output="A comprehensive analysis of Manchester City's current form based on Guardiola's comments."
)

writing_task = Task(
    description='Write a sports article about Manchester City\'s form using the analysis and Guardiola\'s comments.',
    agent=journalist,
    context=[analysis_task],
    expected_output="An engaging sports article about Manchester City's current form and Guardiola's perspective."
)

# Create crew with memory
crew = Crew(
    agents=[sports_analyst, journalist],
    tasks=[analysis_task, writing_task],
    process=Process.sequential,
    memory=True,
    short_term_memory=memory,  # Explicitly pass our memory implementation
    verbose=True
)
```

### Run Agent Memory Demo


```python
# Run the crew with optimized vector index memory
print("Running CrewAI agents with vector index-optimized memory storage...")
start_time = time.time()
result = crew.kickoff()
execution_time = time.time() - start_time

print("\n" + "="*80)
print("CREWAI AGENT MEMORY DEMO RESULT")
print("="*80)
print(result)
print("="*80)
print(f"\n✅ CrewAI agents completed successfully in {execution_time:.2f} seconds!")
print("✅ Agents used vector index-optimized Couchbase memory storage for fast retrieval!")
print("✅ Memory will persist across sessions for continued learning and context retention!")
```

## Memory Retention Testing

### Verify Memory Storage and Retrieval

Test that our agents successfully stored memories and can retrieve them using semantic search.


```python
# Wait for memories to be stored
time.sleep(2)

# List all documents in the collection
try:
    # Query to fetch all documents of this memory type
    query_str = f"SELECT META().id, * FROM `{storage.bucket_name}`.`{storage.scope_name}`.`{storage.collection_name}` WHERE memory_type = $type"
    query_result = storage.cluster.query(query_str, type=storage.type)
    
    print(f"\nAll memory entries in Couchbase:")
    print("-" * 80)
    for i, row in enumerate(query_result, 1):
        doc_id = row.get('id')
        memory_id = row.get(storage.collection_name, {}).get('memory_id', 'unknown')
        content = row.get(storage.collection_name, {}).get('text', '')[:100] + "..."  # Truncate for readability
        
        print(f"Entry {i}: {memory_id}")
        print(f"Content: {content}")
        print("-" * 80)
except Exception as e:
    print(f"Failed to list memory entries: {str(e)}")

# Test memory retention
memory_query = "What is Manchester City's current form according to Guardiola?"
memory_results = storage.search(
    query=memory_query,
    limit=5,  # Increased to see more results
    score_threshold=0.0  # Lower threshold to see all results
)

print("\nMemory Search Results:")
print("-" * 80)
for result in memory_results:
    print(f"Context: {result['context']}")
    print(f"Distance: {result['distance']} (lower = more similar)")
    print("-" * 80)

# Try a more specific query to find agent interactions
interaction_query = "Manchester City playing style analysis tactical"
interaction_results = storage.search(
    query=interaction_query,
    limit=3,
    score_threshold=0.0
)

print("\nAgent Interaction Memory Results:")
print("-" * 80)
if interaction_results:
    for result in interaction_results:
        print(f"Context: {result['context'][:200]}...")  # Limit output size
        print(f"Distance: {result['distance']} (lower = more similar)")
        print("-" * 80)
else:
    print("No interaction memories found. This is normal if agents haven't completed tasks yet.")
    print("-" * 80)
```

    
    All memory entries in Couchbase:
    --------------------------------------------------------------------------------
    
    Memory Search Results:
    --------------------------------------------------------------------------------
    Context: Pep Guardiola praised Manchester City's current form, saying 'The team is playing well, we are in a good moment. The way we are training, the way we are playing - I am really pleased.'
    Distance: 0.285379886892123 (lower = more similar)
    --------------------------------------------------------------------------------
    Context: Manchester City's recent performance analysis under Pep Guardiola reflects a team in strong form and alignment with the manager's philosophy. Guardiola's comments, "The team is playing well, we are in a good moment. The way we are training, the way we are playing - I am really pleased," suggest a high level of satisfaction with both the tactical execution and the overall team ethos on the pitch.
    
    In recent matches, Manchester City has demonstrated their prowess in both domestic and international competitions. This form can be attributed to their meticulous training regimen and strategic flexibility, hallmarks of Guardiola's management style. Over the past few matches, City has maintained a high possession rate, often exceeding 60%, which allows them to control the tempo and dictate the flow of the game. Their attacking prowess is underscored by their goal-scoring statistics, often leading the league in goals scored per match.
    
    One standout example of their performance is their recent dominant victory against a top Premier League rival, where they not only showcased their attacking capabilities but also their defensive solidity, keeping a clean sheet. Key players such as Kevin De Bruyne and Erling Haaland have been instrumental, with De Bruyne's creativity and passing range creating numerous opportunities, while Haaland's clinical finishing has consistently troubled defenses.
    
    Guardiola's system relies heavily on positional play and fluid movement, which has been evident in the team's ability to break down opposition defenses through quick, incisive passes. The team's pressing game has also been a critical component, often winning back possession high up the pitch and quickly transitioning to attack.
    
    Despite Guardiola's positive outlook, potential biases in his comments might overlook some areas needing improvement. For instance, while their attack is formidable, there have been instances where the team has shown vulnerability to counter-attacks, particularly when full-backs are pushed high up the field. Addressing these defensive transitions could be crucial, especially against teams with quick, counter-attacking capabilities.
    
    Looking ahead, Manchester City's current form sets a strong foundation for upcoming challenges, including key fixtures in the Premier League and the knockout stages of the UEFA Champions League. Maintaining this level of performance will be critical as they pursue multiple titles. The team's depth, strategic versatility, and Guardiola's leadership are likely to be decisive factors in sustaining their momentum.
    
    In summary, Manchester City is indeed in a "good moment," as Guardiola states, with their recent performances reflecting a well-oiled machine operating at high efficiency. However, keeping a vigilant eye on potential weaknesses and continuing to adapt tactically will be essential to translating their current form into long-term success.
    Distance: 0.22963345721993045 (lower = more similar)
    --------------------------------------------------------------------------------
    Context: **Manchester City’s Impeccable Form: A Reflection of Guardiola’s Philosophy**
    
    ... (output truncated for brevity)


## Conclusion

You've successfully implemented a custom memory backend for CrewAI agents using Couchbase Hyperscale and Composite Vector Indexes!
